<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - PCD</title>
		<meta charset="utf-8" />
		<meta
			name="viewport"
			content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
		/>
		<link type="text/css" rel="stylesheet" href="main.css" />
	</head>
	<body>
		<!-- <div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a>
			<a
				href="http://pointclouds.org/documentation/tutorials/pcd_file_format.php#pcd-file-format"
				target="_blank"
				rel="noopener"
				>PCD File format</a
			>
			<div>
				PCD loader test by
				<a href="http://filipecaixeta.com.br" target="_blank" rel="noopener"
					>Filipe Caixeta</a
				>
			</div>
			<div>+/-: Increase/Decrease point size</div>
			<div>c: Change color</div> -->
		</div>

		<script type="module">
			import * as THREE from "../build/three.module.js";

			import { OrbitControls } from "./jsm/controls/OrbitControls.js";
			import { PCDLoader } from "./jsm/loaders/PCDLoader.js";

			let camera, scene, renderer;

			init();
			render();


			function init() {
				const PCD_PATH = "./models/pcd/binary_compressed/10001_000.pcd"
				const JSON_PATH = "./models/pcd/binary_compressed/10001_000.json"
				renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				document.body.appendChild(renderer.domElement);

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera(
					30,
					window.innerWidth / window.innerHeight,
					0.01,
					1000
				);
				camera.position.set(0, 0, 200);
				scene.add(camera);

				function readStringFromFileAtPath(pathOfFileToReadFrom)
				{
					var request = new XMLHttpRequest();
					request.open("GET", pathOfFileToReadFrom, false);
					request.send(null);
					var returnValue = request.responseText;

					return returnValue;
				}
			
				function drawLine(p1,p2,z){
					const ax = p1[0]
					const ay = p1[1]
					const az = p1[2]
					const bx = p2[0]
					const by = p2[1]
					const bz = p2[2]
					const material = new THREE.LineBasicMaterial( { color: 0x0000ff } );
					const points = [];
					points.push( new THREE.Vector3( ax,ay,az ) );
					points.push( new THREE.Vector3( bx,by,bz ) );
					
					const geometry = new THREE.BufferGeometry().setFromPoints( points );
					const line = new THREE.Line( geometry, material );
					scene.add( line );
				}
				const text = readStringFromFileAtPath ( JSON_PATH );
				const json_data = JSON.parse(text)
				for(const idx in json_data.annotations){
					const annotation = (json_data.annotations[idx])
					const w = annotation.attribute.dimension[0]
					const h = annotation.attribute.dimension[1]
					const l = annotation.attribute.dimension[2]
					const x = annotation.attribute.location[0]
					const y = annotation.attribute.location[1]
					const z = annotation.attribute.location[2]
					const yaw = annotation.attribute.yaw

					const cy = Math.cos(-yaw)
					const sy = Math.sin(-yaw)
					const bmx = x - cy*l/2
					const bmy = y - sy*l/2
					const tmx = x + cy*l/2
					const tmy = y + sy*l/2

					const x1 = bmx - sy * w/2
					const y1 = bmy + cy * w/2
					const x2 = bmx + sy * w/2
					const y2 = bmy - cy * w/2
					const x3 = tmx + sy * w/2
					const y3 = tmy - cy * w/2
					const x4 = tmx - sy * w/2
					const y4 = tmy + cy * w/2
					const z1 = z - h/2
					const z2 = z + h/2
					const p1 = [x1,y1,z1]
					const p2 = [x2,y2,z1]
					const p3 = [x3,y3,z1]
					const p4 = [x4,y4,z1]

					const p5 = [x1,y1,z2]
					const p6 = [x2,y2,z2]
					const p7 = [x3,y3,z2]
					const p8 = [x4,y4,z2]

					drawLine(p1,p2)
					drawLine(p2,p3)
					drawLine(p3,p4)
					drawLine(p4,p1)

					drawLine(p5,p6)
					drawLine(p6,p7)
					drawLine(p7,p8)
					drawLine(p8,p5)


					drawLine(p1,p5)
					drawLine(p2,p6)
					drawLine(p3,p7)
					drawLine(p4,p8)
				}

				const controls = new OrbitControls(camera, renderer.domElement);
				controls.addEventListener("change", render); // use if there is no animation loop
				controls.minDistance = 0.01;
				controls.maxDistance = 1000;

				//scene.add( new THREE.AxesHelper( 1 ) );

				const loader = new PCDLoader();
				// loader.load("../../10001_000.pcd", function(points) {
				loader.load(
					PCD_PATH,
					// "./models/pcd/binary_compressed/pcl_logo.pcd",
					function(
						// loader.load("./models/pcd/binary_compressed/10260_000.pcd", function(
						points
					) {
						// console.log(points);
						// let colors = new Float32Array(
						// 	points.geometry.attributes.position.count * 3
						// ).fill(255);
						// points.geometry.setAttribute(
						// 	"color",
						// 	new THREE.Float32BufferAttribute(colors, 3)
						// );
						points.material.size = 0.5;
						// console.log(points.material.size);
						scene.add(points);

						render();
					}
				);

				window.addEventListener("resize", onWindowResize);

				window.addEventListener("keypress", keyboard);
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			function keyboard(ev) {
				const points = scene.getObjectByName("10260_000.pcd");

				switch (ev.key || String.fromCharCode(ev.keyCode || ev.charCode)) {
					case "+":
						points.material.size *= 1.2;
						break;

					case "-":
						points.material.size /= 1.2;
						break;

					case "c":
						points.material.color.setHex(Math.random() * 0xffffff);
						break;
				}

				render();
			}

			function render() {
				renderer.render(scene, camera);
			}
		</script>
	</body>
</html>
